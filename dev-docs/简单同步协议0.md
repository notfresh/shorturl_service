同步方案：

目标  
- 增量同步，服务器时间为准，支持幂等、冲突处理、删除追踪。

核心概念  
- `sync_token`：服务器生成的游标，推荐格式为“时间戳+递增序号”（确保严格递增）。  
- `request_id`：客户端每次同步请求的唯一 ID，用于幂等去重。  
- `updated_at`、`deleted_at`（软删）：服务端记录变更时间与删除状态。

API 1：获取最新同步点  
- 路径：GET /sync/last  
- 响应：`sync_token`、`server_time`  
- 语义：返回当前服务端最新同步游标，不依赖客户端时间。

API 2：上传增量变更  
- 路径：POST /sync/upload  
- 请求：  
  - `last_sync_token`（客户端上次成功同步游标）  
  - `request_id`（幂等）  
  - `changes[]`（新增/修改/删除项，含业务数据与客户端时间仅作参考）  
- 响应：  
  - `new_sync_token`（本次处理后的最新游标）  
  - `applied` / `rejected`（按条目返回结果）  
- 幂等：同一 `request_id` 重复提交直接返回同结果。

冲突策略  
- 默认：服务器最后写入胜。  
- 可选：按字段合并或拒绝并返回冲突详情。  
- 需要客户端显示冲突时返回 `conflict` 状态与服务端版本。

删除追踪  
- 采用软删（`deleted_at`）或变更日志表，确保客户端能同步“删除”。

安全与鉴权  
- 请求需带用户身份（token/session）。  
- 所有变更写入审计字段：`updated_by`、`updated_at`、`request_id`。

失败与重试  
- 客户端失败可重试同 `request_id`。  
- 服务端保证幂等，避免重复写入。

建议的数据流程  
1) 客户端启动调用 API1 获取 `sync_token`。  
2) 客户端基于 `last_sync_token` 生成本地增量并调用 API2。  
3) 服务端持久化变更、更新游标并返回 `new_sync_token`。  
4) 客户端保存 `new_sync_token` 供下次使用。

这样能避免时钟漂移、漏同步与重复写入，且可扩展到更多变更类型。