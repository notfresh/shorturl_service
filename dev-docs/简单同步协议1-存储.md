# 存储

思路（不写代码）：

目标  
- 做成“与业务无关”的通用同步存储层，向上提供统一的增量读写、冲突处理、幂等与审计能力。

核心设计  
1) 统一资源模型  
- 任何业务对象都抽象成 `resource_type` + `resource_id`。  
- 统一存储：`payload`（JSON）、`version`、`updated_at`、`deleted_at`、`updated_by`。  
- 这样短链、用户、配置都能走一套同步流程。

2) 变更日志（强烈建议）  
- 维护 `change_log`：`seq`（严格递增）、`resource_type`、`resource_id`、`op`（upsert/delete）、`payload`、`server_time`、`request_id`。  
- `sync_token` = `seq` 或 `server_time + seq`。  
- 优点：避免仅靠 `updated_at` 的漏同步问题，天然支持删除、回放。

3) 幂等层  
- `request_id` + `client_id` 唯一约束，存放 `last_result`。  
- 重复请求直接返回上次结果，不重复写入。

4) 冲突策略层  
- 默认：服务器最后写入胜。  
- 可配置策略：拒绝并返回冲突、基于字段合并。  
- 冲突输出规范化（提供服务端版本快照）。

5) 存取接口（内部）  
- `get_last_token()`  
- `apply_changes(changes, last_sync_token, request_id)`  
- `get_changes_since(token, limit)`（为后续双向同步预留）

6) 索引与分区  
- `change_log.seq` 全局递增索引。  
- `(resource_type, resource_id)` 索引用于幂等/冲突比对。  
- 可按时间分区或归档日志。

7) 安全与审计  
- 必填 `updated_by`、`request_id`、`client_id`。  
- 对关键资源开启“不可物理删除”。

落地建议  
- 先做“变更日志 + 资源表”两层结构。  
- `sync_token` 只用服务端递增序列。  
- 统一 schema 后再接入短链、用户等模块。  

这样能保证通用性、可追溯、可扩展，并能支撑之后的双向同步或离线同步需求。

# 全量数据和增量数据

建议拆成“两层”存储：

1) 全量数据（源事实体表）  
- 资源表：按 `resource_type` / `resource_id` 保存当前最新状态 `payload`。  
- 字段：`version`、`updated_at`、`deleted_at`、`updated_by`。  
- 作用：读“当前态”、业务查询、快速访问。

2) 增量数据（变更日志表）  
- `change_log`：记录每次变更（upsert/delete），字段含 `seq`（全局递增）、`resource_type`、`resource_id`、`op`、`payload`、`server_time`、`request_id`。  
- `sync_token` 直接用 `seq`（或时间戳+seq）。

3) 关联与回放  
- 写入时：先落资源表，再追加日志（或同事务）。  
- 客户端增量：用 `seq > last_token` 拉取。  
- 全量恢复：定期生成“快照”表/备份，然后从快照 + 日志回放到最新。

4) 归档  
- 定期归档旧 `change_log`（已有快照覆盖的部分），降低体量。  
- 保留“最近 N 天”的增量日志用于同步。

这样全量读快、增量同步稳定，且支持回溯与审计。